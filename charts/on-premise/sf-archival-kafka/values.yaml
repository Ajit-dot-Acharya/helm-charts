global:

  postgresql:
    host: ""
    postgresqlDatabase: archival
    postgresqlUsername: snappyflow
    postgresqlPassword: maplelabs
    servicePort: 5432

  kafkaBrokers: ""

  archival:
    enabled: true
    releaseName: archival

  sfAgentInput:
    host: 127.0.0.1
    port: 443
    scheme: https

  snappyflowProjectLabel: snappyflow/projectname
  snappyflowAppLabel: snappyflow/appname

  snappyflowProjectName: "kafkaproject"
  snappyflowAppName: "kafkaapp"

  imagePullSecrets:
  - name: xxxx

creds: "control:$apr1$pjbvxsh8$UnVE6PZ/3874l.cJ.Xc1e0"

nginx-ingress:

  containerResources:
    controller:
      limits:
        cpu: 200m
        memory: 512Mi
      requests:
        cpu: 200m
        memory: 512Mi
    defaultBackend:
      limits:
        cpu: 25m
        memory: 50Mi
      requests:
        cpu: 25m
        memory: 50Mi
    exporter:
      limits:
        cpu: 75m
        memory: 256Mi
      requests:
        cpu: 75m
        memory: 256Mi

cp-schema-registry:

  heapOptions: "-Xms32M -Xmx512M -XX:+UseG1GC -XX:MaxGCPauseMillis=100 -XX:G1HeapRegionSize=1M -XX:MaxMetaspaceSize=256M -XX:MinMetaspaceFreeRatio=10 -XX:MaxMetaspaceFreeRatio=30 -XX:MinHeapFreeRatio=10 -XX:MaxHeapFreeRatio=30"

  containerResources:
    jmx:
      limits:
        cpu: 500m
        memory: 512Mi
      requests:
        cpu: 100m
        memory: 512Mi
    schemaregistry:
      limits:
        cpu: 100m
        memory: 768Mi
      requests:
        cpu: 100m
        memory: 256Mi
    schemaGenerator:
      limits:
        cpu: 100m
        memory: 200Mi
      requests:
        cpu: 50m
        memory: 100Mi

cp-kafka-rest:

  heapOptions: "-Xms32M -Xmx600M -XX:+UseG1GC -XX:MaxGCPauseMillis=50 -XX:G1HeapRegionSize=1M -XX:MaxMetaspaceSize=256M -XX:MinMetaspaceFreeRatio=10 -XX:MaxMetaspaceFreeRatio=30 -XX:MinHeapFreeRatio=10 -XX:MaxHeapFreeRatio=30"

  containerResources:
    restserver:
      limits:
        cpu: 500m
        memory: 1Gi
      requests:
        cpu: 100m
        memory: 512Mi
    jmx:
      limits:
        cpu: 500m
        memory: 512Mi
      requests:
        cpu: 100m
        memory: 512Mi

s3-kafka-connect:

  heapOptions: "-Xms128M -Xmx1512M -XX:+UseG1GC -XX:MaxGCPauseMillis=100 -XX:G1HeapRegionSize=1M -XX:MaxMetaspaceSize=256M -XX:MinMetaspaceFreeRatio=10 -XX:MaxMetaspaceFreeRatio=30 -XX:MinHeapFreeRatio=10 -XX:MaxHeapFreeRatio=30"

  containerResources:
    jmx:
      limits:
        cpu: 500m
        memory: 512Mi
      requests:
        cpu: 100m
        memory: 512Mi
    connector:
      limits:
        cpu: 1000m
        memory: 2.5Gi
      requests:
        cpu: 256m
        memory: 1Gi

es-kafka-connect:

  heapOptions: "-Xms128M -Xmx1512M -XX:+UseG1GC -XX:MaxGCPauseMillis=100 -XX:G1HeapRegionSize=1M -XX:MaxMetaspaceSize=256M -XX:MinMetaspaceFreeRatio=10 -XX:MaxMetaspaceFreeRatio=30 -XX:MinHeapFreeRatio=10 -XX:MaxHeapFreeRatio=30"

  containerResources:
    jmx:
      limits:
        cpu: 500m
        memory: 512Mi
      requests:
        cpu: 100m
        memory: 512Mi
    connector:
      limits:
        cpu: 1000m
        memory: 2.5Gi
      requests:
        cpu: 256m
        memory: 1Gi

autoscaling:
  ## Auto scaling configuration
  ## Support for Kafka REST, Archivak Kafka Connect and ES Kafka Connect
  enabled: true

  ## If enabled prometheus server and adapter will be installed to serve custom
  ## metrics
  customMetrics:
    enabled: true

  archivalConnectAutoscaling:
    enabled: true
    minReplicas: 1
    maxReplicas: 5
    cpu:
      targetAverageValue: 850m # 85% of CPU allocated to connector
    memory:
      targetAverageValue: 1644 # MiB -> When memory utilization reaches x Mib, auto-scaling kicks in. Value should be ~65% of kafka-connect connector container memory limit

  apmConnectAutoscaling:
    enabled: true
    minReplicas: 3
    maxReplicas: 5
    cpu:
      targetAverageValue: 850m # 85% of CPU allocated to connector
    memory:
      targetAverageValue: 1644 # MiB -> When memory utilization reaches x Mib, auto-scaling kicks in. Value should be ~65% of kafka-connect connector container memory limit

  restKafkaAutoscaling:
    enabled: true
    minReplicas: 1
    maxReplicas: 5
    cpu:
      targetAverageValue: 450m # 90% of CPU allocated to rest-server
    memory:
      targetAverageValue: 750 # MiB -> When memory utilization reaches x Mib, auto-scaling kicks in. Value should be ~75% of kafka-connect connector container memory limit

  resources:
    limits:
      cpu: 200m
      memory: 256Mi
    requests:
      cpu: 100m
      memory: 150Mi

authenticator:

  admin:
    profileKey: admin
    userName: admin
    password: admin

  signingKey: "mysecretkey"

  containerResources:
    authenticator:
      limits:
        cpu: 200m
        memory: 256Mi
      requests:
        cpu: 200m
        memory: 256Mi

sfk-interface:

  containerResources:
    interface:
      limits:
        cpu: 100m
        memory: 200Mi
      requests:
        cpu: 50m
        memory: 100Mi

  cron:
    containerResources:
      limits:
        cpu: 25m
        memory: 50Mi
      requests:
        cpu: 10m
        memory: 25Mi

signatures:

  containerResources:
    signatures:
      limits:
        cpu: 200m
        memory: 512Mi
      requests:
        cpu: 100m
        memory: 512Mi
